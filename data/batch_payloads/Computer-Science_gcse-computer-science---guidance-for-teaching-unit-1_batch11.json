{
  "subject": "Computer-Science",
  "filename": "gcse-computer-science---guidance-for-teaching-unit-1.md",
  "batch_index": 11,
  "issue_count": 10,
  "prompts": [
    "You are an expert proofreader and copy-editor, specialising in the final-pass review of documents for the Welsh Joint Education Committee (WJEC). You have an exceptional eye for detail, understanding that ever the smallest error can undermine the credibility of the entire document.\nYou possess specialist knowledge of Welsh educational terminology, WJEC-specific stylistic idioms, and common documentation formats.\nYour analysis must be uncompromisingly rigorous to catch all errors. Failure to do so will result in severe reputational damage to the WJEC. It will also disappoint the students and teachers who rely on the WJEC to provide accurate and reliable educational materials.\n<!--\n  Template context contract (provided by prompt_factory.py):\n    subject         -> string (e.g., \"Art-and-Design\")\n    filename        -> string (e.g., \"gcse-art-and-design---guidance-for-teaching.md\")\n    issue_table     -> Markdown string representing the batch table\n    page_context    -> iterable of { page_number: int, content: str }\n    retry_context?  -> optional note when re-asking the model (not currently used)\n-->\n\n## Document Under Review\n\nYou are reviewing **Computer-Science / gcse-computer-science---guidance-for-teaching-unit-1.md** from the WJEC Made-for-Wales 2025 GCSE documentation set. Treat this as a high-stakes proofread: every issue in the table below must be checked against the provided page excerpts.\n\n## Inputs\n\n1. **Issue Batch (Table):** Each row mirrors the original LanguageTool output for the current batch of issues.\n2. **Page Context:** The raw Markdown for each page referenced by this batch. Use it to confirm what the learner-facing document actually says.\n\n---\n\n## Task\n\nYour role is to act as a specialist linguistic validator, reassessing every row in the issue table. Do **not** rely on the LanguageTool `Type` or message alone\u2014use the page context, your WJEC domain knowledge, and authoritative sources to decide whether the suggestion is correct, optional, or a false alarm.\n\n---\n\n\n---\n\n### Guiding Principles & Authoritative Sources\n\n* **Validator's Stance:** Your primary duty is to protect linguistic quality. The burden of proof is on the **tool's suggestion**. Assume the original `[DOCUMENT TO REVIEW]` is correct unless the tool's suggestion definitively corrects an unambiguous error.\n* **Authoritative Sources:** When in doubt, especially for `Spelling Error` or `False Positive` decisions, you must consult authoritative sources.\n    * **UK English:** Oxford English Dictionary (OED), Collins Dictionary.\n    * **Welsh:** Geiriadur Prifysgol Cymru (GPC), Termau Cyd.\n    * **French:** Dictionnaire de l'Acad\u00e9mie Fran\u00e7aise, Larousse.\n    * **German:** Duden.\n    * **Spanish:** Diccionario de la lengua espa\u00f1ola (RAE).\n    * **Specialist Terms:** Refer to the `[DOCUMENT TO REVIEW]` for context.\n## Decision-Making Workflow\n\nFor **each issue** in the table:\n\n1. **Locate & Understand:** Use `context_from_tool` and the page excerpt to confirm the exact wording.\n2. **Evaluate:** Judge the reported problem against authoritative sources and WJEC conventions.\n3. **Categorise:** Choose one category from the list below (machine-readable enum values).\n4. **Score:** Provide a confidence score between 0\u2013100 (integers only).\n5. **Justify:** Supply a single concise sentence explaining the decision.\n\n\n## Output Format\n\nReturn a **single top-level JSON array** (no surrounding object, no page keys) and nothing else. Do not include backticks, commentary, or any text before or after the JSON. Each array element represents one issue from the table.\n\nIMPORTANT: the categoriser only needs to provide the LLM results for each issue \u2014 the detection fields are already known from the input CSV and are re-applied server-side. For each issue, return exactly the following fields and nothing more:\n\n- `issue_id`: integer \u2014 the issue identifier from the input CSV (auto-increment per-document)\n- `error_category`: one of the enum values listed in \"Error Categories\" above (e.g., `PARSING_ERROR`)\n- `confidence_score`: integer 0\u2013100 (if you prefer to provide 0\u20131 floats, the runner will convert them)\n- `reasoning`: single-sentence justification\n\nExample minimal output:\n```json\n[\n  {\n    \"issue_id\": 0,\n    \"error_category\": \"POSSIBLE_AMBIGUOUS_GRAMMATICAL_ERROR\",\n    \"confidence_score\": 70,\n    \"reasoning\": \"Comma improves clarity but omission is not a factual error.\"\n  },\n  {\n    \"issue_id\": 1,\n    \"error_category\": \"PARSING_ERROR\",\n    \"confidence_score\": 90,\n    \"reasoning\": \"Hyphenation required for compound adjective in UK English.\"\n  }\n]\n```\n\nEach error object **must** include only the four fields described above \u2014 `issue_id`, `error_category`, `confidence_score`, and `reasoning`. The runner will map `issue_id` back to the original detection row and attach the LLM fields to that issue.\n\nIMPORTANT: Always return a JSON array even for a single issue. For example, the array must be:\n\n```json\n[\n  {\n    \"issue_id\": 0,\n    \"error_category\": \"PARSING_ERROR\",\n    \"confidence_score\": 90,\n    \"reasoning\": \"Short single-sentence reason\"\n  }\n]\n```\n\nDo not return the single object without wrapping it in an array. Also ensure every string uses double-quotes and there are no trailing commas.\n\n---",
    "<!-- Document header (header, inputs, task) is defined in the system prompt\n\tto keep static role instructions separate from per-batch content. -->\n\n## Issue Batch\n\n### Page 62\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 110 | rstrip | ...ns a right trim version of the string \\| **rstrip**() \\| \\| Split \\| Splits the string at the ... |\n| 111 | splitlines | ...ing at line breaks and returns a list \\| **splitlines**() \\| \\| Strip \\| Returns a trimmed version... |\n\nPage context:\n```markdown\n{62}------------------------------------------------\n\n| Left trim | Returns a left trim version of the string | lstrip() |\n|------------|-----------------------------------------------------------------------------------|--------------|\n| Replace | Returns a string where a specified value is replaced with a specified value | replace() |\n| Right trim | Returns a right trim version of the string | rstrip() |\n| Split | Splits the string at the specified separator, and returns a list | split() |\n| Split Line | Splits the string at line breaks and returns a list | splitlines() |\n| Strip | Returns a trimmed version of the string | strip() |\n| Uppercase | Converts a string into upper case | upper() |\n\n#### **Mathematical**\n\n| Operator | Definition                  | Example                                                                                                       |\n|----------|-----------------------------|---------------------------------------------------------------------------------------------------------------|\n| > | Greater than | A>B will return TRUE if the value of A is higher than the value of B otherwise it will return FALSE. |\n| >= | Greater than or equal to | A>=B will return TRUE if A is the same as or higher than B otherwise it will return FALSE. |\n\n\n```\n\n---\n### Page 63\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 112 | br | ... \\| Less than \\| A &lt;b if=&quot;&quot; return=&quot;&quot; the&lt;**br**=&quot;&quot; true=&quot;&quot; will=&quot;&quot;&gt;value of A is lower ... |\n| 113 | &lt;= | ...--------\\|--\\| \\| Less than or equal to \\| A**&lt;=**B will return TRUE if A is the same as o... |\n\nPage context:\n```markdown\n{63}------------------------------------------------\n\n| Less than | A <b if=\"\" return=\"\" the<br=\"\" true=\"\" will=\"\">value of A is lower that the value of B otherwise it will return FALSE.</b> |  |\n|---------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|--|\n| Less than or equal to | A<=B will return TRUE if A is the same as or lower than B otherwise it will return FALSE. |  |\n| Not equal to | A<>B will return TRUE if A is not the same as B but FALSE if A is the same as B. |  |\n| Equals or the same as | A==B will return TRUE if A is the same as B otherwise it will return FALSE. |  |\n| Integer division Finds the quotient or the 'whole number of times' a divisor can be divided into a number. | 21 DIV 4 = 5 The quotient is 5 as 4 divides into 21 a whole number of 5 times. |  |\n| Modulo division Finds the remainder when a divisor is divided into a number. | 21 MOD 2 = 1 The remainder is 1 as 2 divides 10 times into 21 with a remainder of 1. |  |\n|                                                                                                                           | !=                                                                                                                                     |  |\n\n\n```\n\n---\n### Page 64\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 114 | subprocedure | ...y can only be accessed from within that **subprocedure**.  **Global variables** are declared in ... |\n| 115 | outside of | ...les** are declared in the main program, **outside of** subprocedures. They have &#x27;global scope&#x27;... |\n| 116 | subprocedures | ...eclared in the main program, outside of **subprocedures**. They have &#x27;global scope&#x27; because they ... |\n\nPage context:\n```markdown\n{64}------------------------------------------------\n\n| Logical operations |\n|--------------------|\n|                    |\n\n| Operator | Definition                                                                                                                                                                   | Example                                                                                                                  |\n|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| AND | Both statements must be true for the argument as a whole to be true | (A == 1) AND (B==4) will return TRUE if A is 1 and B is 4. It would return FALSE in all other situations. |\n| NOT | The opposite of True input. | NOT(A) will return TRUE if A is FALSE and FALSE if A is TRUE. |\n| OR | Only one of the statements needs to be true for the argument as a whole to be true. | (A==1) OR (B==4) will return TRUE if A is 1 or B is 4. It would only return FALSE if A is not 1 and B is not 4. |\n| XOR | The argument is false if both statements are true. The argument is false if both statements are false. Otherwise, the statement is true. | A XOR B would return TRUE if A and B are different values. |\n\n**Local variables** are declared in a sub-procedure. They have 'local scope' because they can only be accessed from within that subprocedure.\n\n**Global variables** are declared in the main program, outside of subprocedures. They have 'global scope' because they can be accessed from all parts of the program.\n\n\n```\n\n---\n### Page 65\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 117 | myArray | ... structures that can be defined as such **myArray**[6]. This would mean that the array has ... |\n| 118 | myArray | ...rst element will be located in position **myArray**[0]. - **2-D arrays** are data structure... |\n| 119 | myArray | ...and tables, that can be defined as such **myArray**[6, 5]. This would mean that the array h... |\n\nPage context:\n```markdown\n{65}------------------------------------------------\n\n- **1-D arrays** are linear data structures that can be defined as such myArray[6]. This would mean that the array has 6 elements within it. The first element will be located in position myArray[0].\n- **2-D arrays** are data structures that are made up of rows and tables, that can be defined as such myArray[6, 5]. This would mean that the array has 6 elements in rows and 5 in columns. The first element will be located in position myArray[0, 0].\n\n#### **Characteristics of search algorithms:**\n\n\u2022 **Linear search** will search through a data structure sequentially. Array data structures will be search in a linear fashion. Linear searches can be performed by unsorted data structures.\n\n```\nDeclare linearSearch(dataList, searchItem) \nposition = 0 \nfound = false \nwhile position < len(dataList) and found = false \n if dataList[position] = searchItem then \n found = true \n else \n position = position + 1 \n end if \nend while\n```\n\n\u2022 **Binary search** will find the midpoint of a data structure and compare that element against the search item. If the search item is not found it will discard the half of the data structure that will not contain the search item and repeat the process of finding the midpoint. It will repeat all processes until the search item is found. This search can only be done on sorted data structures.\n\n```\nsearchChar is char \nfirst is integer\n```\n\n\n```\n\n---\n\n\n---\n\n## Page Context\n\nReview each page excerpt before making decisions. Pages appear in ascending order and always include the page marker line.\n\n### Page 62\n```markdown\n{62}------------------------------------------------\n\n| Left trim | Returns a left trim version of the string | lstrip() |\n|------------|-----------------------------------------------------------------------------------|--------------|\n| Replace | Returns a string where a specified value is replaced with a specified value | replace() |\n| Right trim | Returns a right trim version of the string | rstrip() |\n| Split | Splits the string at the specified separator, and returns a list | split() |\n| Split Line | Splits the string at line breaks and returns a list | splitlines() |\n| Strip | Returns a trimmed version of the string | strip() |\n| Uppercase | Converts a string into upper case | upper() |\n\n#### **Mathematical**\n\n| Operator | Definition                  | Example                                                                                                       |\n|----------|-----------------------------|---------------------------------------------------------------------------------------------------------------|\n| > | Greater than | A>B will return TRUE if the value of A is higher than the value of B otherwise it will return FALSE. |\n| >= | Greater than or equal to | A>=B will return TRUE if A is the same as or higher than B otherwise it will return FALSE. |\n\n\n```\n\n### Page 63\n```markdown\n{63}------------------------------------------------\n\n| Less than | A <b if=\"\" return=\"\" the<br=\"\" true=\"\" will=\"\">value of A is lower that the value of B otherwise it will return FALSE.</b> |  |\n|---------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|--|\n| Less than or equal to | A<=B will return TRUE if A is the same as or lower than B otherwise it will return FALSE. |  |\n| Not equal to | A<>B will return TRUE if A is not the same as B but FALSE if A is the same as B. |  |\n| Equals or the same as | A==B will return TRUE if A is the same as B otherwise it will return FALSE. |  |\n| Integer division Finds the quotient or the 'whole number of times' a divisor can be divided into a number. | 21 DIV 4 = 5 The quotient is 5 as 4 divides into 21 a whole number of 5 times. |  |\n| Modulo division Finds the remainder when a divisor is divided into a number. | 21 MOD 2 = 1 The remainder is 1 as 2 divides 10 times into 21 with a remainder of 1. |  |\n|                                                                                                                           | !=                                                                                                                                     |  |\n\n\n```\n\n### Page 64\n```markdown\n{64}------------------------------------------------\n\n| Logical operations |\n|--------------------|\n|                    |\n\n| Operator | Definition                                                                                                                                                                   | Example                                                                                                                  |\n|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| AND | Both statements must be true for the argument as a whole to be true | (A == 1) AND (B==4) will return TRUE if A is 1 and B is 4. It would return FALSE in all other situations. |\n| NOT | The opposite of True input. | NOT(A) will return TRUE if A is FALSE and FALSE if A is TRUE. |\n| OR | Only one of the statements needs to be true for the argument as a whole to be true. | (A==1) OR (B==4) will return TRUE if A is 1 or B is 4. It would only return FALSE if A is not 1 and B is not 4. |\n| XOR | The argument is false if both statements are true. The argument is false if both statements are false. Otherwise, the statement is true. | A XOR B would return TRUE if A and B are different values. |\n\n**Local variables** are declared in a sub-procedure. They have 'local scope' because they can only be accessed from within that subprocedure.\n\n**Global variables** are declared in the main program, outside of subprocedures. They have 'global scope' because they can be accessed from all parts of the program.\n\n\n```\n\n### Page 65\n```markdown\n{65}------------------------------------------------\n\n- **1-D arrays** are linear data structures that can be defined as such myArray[6]. This would mean that the array has 6 elements within it. The first element will be located in position myArray[0].\n- **2-D arrays** are data structures that are made up of rows and tables, that can be defined as such myArray[6, 5]. This would mean that the array has 6 elements in rows and 5 in columns. The first element will be located in position myArray[0, 0].\n\n#### **Characteristics of search algorithms:**\n\n\u2022 **Linear search** will search through a data structure sequentially. Array data structures will be search in a linear fashion. Linear searches can be performed by unsorted data structures.\n\n```\nDeclare linearSearch(dataList, searchItem) \nposition = 0 \nfound = false \nwhile position < len(dataList) and found = false \n if dataList[position] = searchItem then \n found = true \n else \n position = position + 1 \n end if \nend while\n```\n\n\u2022 **Binary search** will find the midpoint of a data structure and compare that element against the search item. If the search item is not found it will discard the half of the data structure that will not contain the search item and repeat the process of finding the midpoint. It will repeat all processes until the search item is found. This search can only be done on sorted data structures.\n\n```\nsearchChar is char \nfirst is integer\n```\n\n\n```\n\n\n---"
  ],
  "system": "You are an expert proofreader and copy-editor, specialising in the final-pass review of documents for the Welsh Joint Education Committee (WJEC). You have an exceptional eye for detail, understanding that ever the smallest error can undermine the credibility of the entire document.\nYou possess specialist knowledge of Welsh educational terminology, WJEC-specific stylistic idioms, and common documentation formats.\nYour analysis must be uncompromisingly rigorous to catch all errors. Failure to do so will result in severe reputational damage to the WJEC. It will also disappoint the students and teachers who rely on the WJEC to provide accurate and reliable educational materials.\n<!--\n  Template context contract (provided by prompt_factory.py):\n    subject         -> string (e.g., \"Art-and-Design\")\n    filename        -> string (e.g., \"gcse-art-and-design---guidance-for-teaching.md\")\n    issue_table     -> Markdown string representing the batch table\n    page_context    -> iterable of { page_number: int, content: str }\n    retry_context?  -> optional note when re-asking the model (not currently used)\n-->\n\n## Document Under Review\n\nYou are reviewing **Computer-Science / gcse-computer-science---guidance-for-teaching-unit-1.md** from the WJEC Made-for-Wales 2025 GCSE documentation set. Treat this as a high-stakes proofread: every issue in the table below must be checked against the provided page excerpts.\n\n## Inputs\n\n1. **Issue Batch (Table):** Each row mirrors the original LanguageTool output for the current batch of issues.\n2. **Page Context:** The raw Markdown for each page referenced by this batch. Use it to confirm what the learner-facing document actually says.\n\n---\n\n## Task\n\nYour role is to act as a specialist linguistic validator, reassessing every row in the issue table. Do **not** rely on the LanguageTool `Type` or message alone\u2014use the page context, your WJEC domain knowledge, and authoritative sources to decide whether the suggestion is correct, optional, or a false alarm.\n\n---\n\n\n---\n\n### Guiding Principles & Authoritative Sources\n\n* **Validator's Stance:** Your primary duty is to protect linguistic quality. The burden of proof is on the **tool's suggestion**. Assume the original `[DOCUMENT TO REVIEW]` is correct unless the tool's suggestion definitively corrects an unambiguous error.\n* **Authoritative Sources:** When in doubt, especially for `Spelling Error` or `False Positive` decisions, you must consult authoritative sources.\n    * **UK English:** Oxford English Dictionary (OED), Collins Dictionary.\n    * **Welsh:** Geiriadur Prifysgol Cymru (GPC), Termau Cyd.\n    * **French:** Dictionnaire de l'Acad\u00e9mie Fran\u00e7aise, Larousse.\n    * **German:** Duden.\n    * **Spanish:** Diccionario de la lengua espa\u00f1ola (RAE).\n    * **Specialist Terms:** Refer to the `[DOCUMENT TO REVIEW]` for context.\n## Decision-Making Workflow\n\nFor **each issue** in the table:\n\n1. **Locate & Understand:** Use `context_from_tool` and the page excerpt to confirm the exact wording.\n2. **Evaluate:** Judge the reported problem against authoritative sources and WJEC conventions.\n3. **Categorise:** Choose one category from the list below (machine-readable enum values).\n4. **Score:** Provide a confidence score between 0\u2013100 (integers only).\n5. **Justify:** Supply a single concise sentence explaining the decision.\n\n\n## Output Format\n\nReturn a **single top-level JSON array** (no surrounding object, no page keys) and nothing else. Do not include backticks, commentary, or any text before or after the JSON. Each array element represents one issue from the table.\n\nIMPORTANT: the categoriser only needs to provide the LLM results for each issue \u2014 the detection fields are already known from the input CSV and are re-applied server-side. For each issue, return exactly the following fields and nothing more:\n\n- `issue_id`: integer \u2014 the issue identifier from the input CSV (auto-increment per-document)\n- `error_category`: one of the enum values listed in \"Error Categories\" above (e.g., `PARSING_ERROR`)\n- `confidence_score`: integer 0\u2013100 (if you prefer to provide 0\u20131 floats, the runner will convert them)\n- `reasoning`: single-sentence justification\n\nExample minimal output:\n```json\n[\n  {\n    \"issue_id\": 0,\n    \"error_category\": \"POSSIBLE_AMBIGUOUS_GRAMMATICAL_ERROR\",\n    \"confidence_score\": 70,\n    \"reasoning\": \"Comma improves clarity but omission is not a factual error.\"\n  },\n  {\n    \"issue_id\": 1,\n    \"error_category\": \"PARSING_ERROR\",\n    \"confidence_score\": 90,\n    \"reasoning\": \"Hyphenation required for compound adjective in UK English.\"\n  }\n]\n```\n\nEach error object **must** include only the four fields described above \u2014 `issue_id`, `error_category`, `confidence_score`, and `reasoning`. The runner will map `issue_id` back to the original detection row and attach the LLM fields to that issue.\n\nIMPORTANT: Always return a JSON array even for a single issue. For example, the array must be:\n\n```json\n[\n  {\n    \"issue_id\": 0,\n    \"error_category\": \"PARSING_ERROR\",\n    \"confidence_score\": 90,\n    \"reasoning\": \"Short single-sentence reason\"\n  }\n]\n```\n\nDo not return the single object without wrapping it in an array. Also ensure every string uses double-quotes and there are no trailing commas.\n\n---",
  "user": [
    "<!-- Document header (header, inputs, task) is defined in the system prompt\n\tto keep static role instructions separate from per-batch content. -->\n\n## Issue Batch\n\n### Page 62\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 110 | rstrip | ...ns a right trim version of the string \\| **rstrip**() \\| \\| Split \\| Splits the string at the ... |\n| 111 | splitlines | ...ing at line breaks and returns a list \\| **splitlines**() \\| \\| Strip \\| Returns a trimmed version... |\n\nPage context:\n```markdown\n{62}------------------------------------------------\n\n| Left trim | Returns a left trim version of the string | lstrip() |\n|------------|-----------------------------------------------------------------------------------|--------------|\n| Replace | Returns a string where a specified value is replaced with a specified value | replace() |\n| Right trim | Returns a right trim version of the string | rstrip() |\n| Split | Splits the string at the specified separator, and returns a list | split() |\n| Split Line | Splits the string at line breaks and returns a list | splitlines() |\n| Strip | Returns a trimmed version of the string | strip() |\n| Uppercase | Converts a string into upper case | upper() |\n\n#### **Mathematical**\n\n| Operator | Definition                  | Example                                                                                                       |\n|----------|-----------------------------|---------------------------------------------------------------------------------------------------------------|\n| > | Greater than | A>B will return TRUE if the value of A is higher than the value of B otherwise it will return FALSE. |\n| >= | Greater than or equal to | A>=B will return TRUE if A is the same as or higher than B otherwise it will return FALSE. |\n\n\n```\n\n---\n### Page 63\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 112 | br | ... \\| Less than \\| A &lt;b if=&quot;&quot; return=&quot;&quot; the&lt;**br**=&quot;&quot; true=&quot;&quot; will=&quot;&quot;&gt;value of A is lower ... |\n| 113 | &lt;= | ...--------\\|--\\| \\| Less than or equal to \\| A**&lt;=**B will return TRUE if A is the same as o... |\n\nPage context:\n```markdown\n{63}------------------------------------------------\n\n| Less than | A <b if=\"\" return=\"\" the<br=\"\" true=\"\" will=\"\">value of A is lower that the value of B otherwise it will return FALSE.</b> |  |\n|---------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|--|\n| Less than or equal to | A<=B will return TRUE if A is the same as or lower than B otherwise it will return FALSE. |  |\n| Not equal to | A<>B will return TRUE if A is not the same as B but FALSE if A is the same as B. |  |\n| Equals or the same as | A==B will return TRUE if A is the same as B otherwise it will return FALSE. |  |\n| Integer division Finds the quotient or the 'whole number of times' a divisor can be divided into a number. | 21 DIV 4 = 5 The quotient is 5 as 4 divides into 21 a whole number of 5 times. |  |\n| Modulo division Finds the remainder when a divisor is divided into a number. | 21 MOD 2 = 1 The remainder is 1 as 2 divides 10 times into 21 with a remainder of 1. |  |\n|                                                                                                                           | !=                                                                                                                                     |  |\n\n\n```\n\n---\n### Page 64\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 114 | subprocedure | ...y can only be accessed from within that **subprocedure**.  **Global variables** are declared in ... |\n| 115 | outside of | ...les** are declared in the main program, **outside of** subprocedures. They have &#x27;global scope&#x27;... |\n| 116 | subprocedures | ...eclared in the main program, outside of **subprocedures**. They have &#x27;global scope&#x27; because they ... |\n\nPage context:\n```markdown\n{64}------------------------------------------------\n\n| Logical operations |\n|--------------------|\n|                    |\n\n| Operator | Definition                                                                                                                                                                   | Example                                                                                                                  |\n|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| AND | Both statements must be true for the argument as a whole to be true | (A == 1) AND (B==4) will return TRUE if A is 1 and B is 4. It would return FALSE in all other situations. |\n| NOT | The opposite of True input. | NOT(A) will return TRUE if A is FALSE and FALSE if A is TRUE. |\n| OR | Only one of the statements needs to be true for the argument as a whole to be true. | (A==1) OR (B==4) will return TRUE if A is 1 or B is 4. It would only return FALSE if A is not 1 and B is not 4. |\n| XOR | The argument is false if both statements are true. The argument is false if both statements are false. Otherwise, the statement is true. | A XOR B would return TRUE if A and B are different values. |\n\n**Local variables** are declared in a sub-procedure. They have 'local scope' because they can only be accessed from within that subprocedure.\n\n**Global variables** are declared in the main program, outside of subprocedures. They have 'global scope' because they can be accessed from all parts of the program.\n\n\n```\n\n---\n### Page 65\n| issue_id | issue | highlighted_context |\n| --- | --- | --- |\n| 117 | myArray | ... structures that can be defined as such **myArray**[6]. This would mean that the array has ... |\n| 118 | myArray | ...rst element will be located in position **myArray**[0]. - **2-D arrays** are data structure... |\n| 119 | myArray | ...and tables, that can be defined as such **myArray**[6, 5]. This would mean that the array h... |\n\nPage context:\n```markdown\n{65}------------------------------------------------\n\n- **1-D arrays** are linear data structures that can be defined as such myArray[6]. This would mean that the array has 6 elements within it. The first element will be located in position myArray[0].\n- **2-D arrays** are data structures that are made up of rows and tables, that can be defined as such myArray[6, 5]. This would mean that the array has 6 elements in rows and 5 in columns. The first element will be located in position myArray[0, 0].\n\n#### **Characteristics of search algorithms:**\n\n\u2022 **Linear search** will search through a data structure sequentially. Array data structures will be search in a linear fashion. Linear searches can be performed by unsorted data structures.\n\n```\nDeclare linearSearch(dataList, searchItem) \nposition = 0 \nfound = false \nwhile position < len(dataList) and found = false \n if dataList[position] = searchItem then \n found = true \n else \n position = position + 1 \n end if \nend while\n```\n\n\u2022 **Binary search** will find the midpoint of a data structure and compare that element against the search item. If the search item is not found it will discard the half of the data structure that will not contain the search item and repeat the process of finding the midpoint. It will repeat all processes until the search item is found. This search can only be done on sorted data structures.\n\n```\nsearchChar is char \nfirst is integer\n```\n\n\n```\n\n---\n\n\n---\n\n## Page Context\n\nReview each page excerpt before making decisions. Pages appear in ascending order and always include the page marker line.\n\n### Page 62\n```markdown\n{62}------------------------------------------------\n\n| Left trim | Returns a left trim version of the string | lstrip() |\n|------------|-----------------------------------------------------------------------------------|--------------|\n| Replace | Returns a string where a specified value is replaced with a specified value | replace() |\n| Right trim | Returns a right trim version of the string | rstrip() |\n| Split | Splits the string at the specified separator, and returns a list | split() |\n| Split Line | Splits the string at line breaks and returns a list | splitlines() |\n| Strip | Returns a trimmed version of the string | strip() |\n| Uppercase | Converts a string into upper case | upper() |\n\n#### **Mathematical**\n\n| Operator | Definition                  | Example                                                                                                       |\n|----------|-----------------------------|---------------------------------------------------------------------------------------------------------------|\n| > | Greater than | A>B will return TRUE if the value of A is higher than the value of B otherwise it will return FALSE. |\n| >= | Greater than or equal to | A>=B will return TRUE if A is the same as or higher than B otherwise it will return FALSE. |\n\n\n```\n\n### Page 63\n```markdown\n{63}------------------------------------------------\n\n| Less than | A <b if=\"\" return=\"\" the<br=\"\" true=\"\" will=\"\">value of A is lower that the value of B otherwise it will return FALSE.</b> |  |\n|---------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------|--|\n| Less than or equal to | A<=B will return TRUE if A is the same as or lower than B otherwise it will return FALSE. |  |\n| Not equal to | A<>B will return TRUE if A is not the same as B but FALSE if A is the same as B. |  |\n| Equals or the same as | A==B will return TRUE if A is the same as B otherwise it will return FALSE. |  |\n| Integer division Finds the quotient or the 'whole number of times' a divisor can be divided into a number. | 21 DIV 4 = 5 The quotient is 5 as 4 divides into 21 a whole number of 5 times. |  |\n| Modulo division Finds the remainder when a divisor is divided into a number. | 21 MOD 2 = 1 The remainder is 1 as 2 divides 10 times into 21 with a remainder of 1. |  |\n|                                                                                                                           | !=                                                                                                                                     |  |\n\n\n```\n\n### Page 64\n```markdown\n{64}------------------------------------------------\n\n| Logical operations |\n|--------------------|\n|                    |\n\n| Operator | Definition                                                                                                                                                                   | Example                                                                                                                  |\n|----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|\n| AND | Both statements must be true for the argument as a whole to be true | (A == 1) AND (B==4) will return TRUE if A is 1 and B is 4. It would return FALSE in all other situations. |\n| NOT | The opposite of True input. | NOT(A) will return TRUE if A is FALSE and FALSE if A is TRUE. |\n| OR | Only one of the statements needs to be true for the argument as a whole to be true. | (A==1) OR (B==4) will return TRUE if A is 1 or B is 4. It would only return FALSE if A is not 1 and B is not 4. |\n| XOR | The argument is false if both statements are true. The argument is false if both statements are false. Otherwise, the statement is true. | A XOR B would return TRUE if A and B are different values. |\n\n**Local variables** are declared in a sub-procedure. They have 'local scope' because they can only be accessed from within that subprocedure.\n\n**Global variables** are declared in the main program, outside of subprocedures. They have 'global scope' because they can be accessed from all parts of the program.\n\n\n```\n\n### Page 65\n```markdown\n{65}------------------------------------------------\n\n- **1-D arrays** are linear data structures that can be defined as such myArray[6]. This would mean that the array has 6 elements within it. The first element will be located in position myArray[0].\n- **2-D arrays** are data structures that are made up of rows and tables, that can be defined as such myArray[6, 5]. This would mean that the array has 6 elements in rows and 5 in columns. The first element will be located in position myArray[0, 0].\n\n#### **Characteristics of search algorithms:**\n\n\u2022 **Linear search** will search through a data structure sequentially. Array data structures will be search in a linear fashion. Linear searches can be performed by unsorted data structures.\n\n```\nDeclare linearSearch(dataList, searchItem) \nposition = 0 \nfound = false \nwhile position < len(dataList) and found = false \n if dataList[position] = searchItem then \n found = true \n else \n position = position + 1 \n end if \nend while\n```\n\n\u2022 **Binary search** will find the midpoint of a data structure and compare that element against the search item. If the search item is not found it will discard the half of the data structure that will not contain the search item and repeat the process of finding the midpoint. It will repeat all processes until the search item is found. This search can only be done on sorted data structures.\n\n```\nsearchChar is char \nfirst is integer\n```\n\n\n```\n\n\n---"
  ]
}